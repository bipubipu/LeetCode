## Challenge
https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/528/week-1/3284/

Write an algorithm to determine if a number n is "happy".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Return True if n is a happy number, and False if not.

Example: 

Input: 19
Output: true
Explanation: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

## Thinking process
The first problem to tackle is splitting digits. There are many ways of doing it, like using mod(). But I personally chose transferring the number into a string and take each digit out. The second thing is to control when to break the loop. A number no matter Happy or not can lead to endless loop. My initial failured attemps didn't consider when to jump out with 'return False'. My judgement is based on if the sum is 1 or if it appears before.

``` Python
class Solution:
    def isHappy(self, n):
        results = [n]
        # Keep this running until the number equals 1 or the sum appears more than once.
        while 1:
            # Get every digit of the number by transforming it into a string.
            
            result = sum(int(digit) ** 2 for digit in str(n)) 
            if result == 1:
                return True
            
            # Result needs to be recorded because if it appears more than once, it means this number is not Happy Number
            
            elif result in results:    
                return False
            else:
                results.append(result)
                n = result
```   
Time complexity: O(logn). The loop will take O(logn). Inside the loop, there is 'if in' which needs O(logn) time.
Space complexity: O(logn)

## Other solutions
### HashSet 
This method is similar to mine but it defines a method to calculate the sum and uses Set to store numbers.

``` Python
def isHappy(self, n):

    def get_next(n):
        total_sum = 0
        while n > 0:
            n, digit = divmod(n, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)

    return n == 1
```
Time complexity: O(logn)
Space complexity: O(logn)

### Fast and slow pointer
It's also Floyd Cycle detection algorithm, which is often used to detect linked list cycle problem.
The next number is generated by the previous one. If we connect them together, that's linked list. But if it's not Happy Number, it will form a cycle. If we have rabbit (2 steps per time) and turtle (1 step per time), they will eventually meet in unhappy number case.
For Happy Number, the value of ending point is 1.


``` Python
def isHappy(self, n):  
    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    slow_runner = n
    fast_runner = get_next(n)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next(slow_runner)
        fast_runner = get_next(get_next(fast_runner))
    return fast_runner == 1
```
Time complexity: O(logn)
Space complexity: O(1)

### Math
| Digits | Largest       | Next |
| ------ |:-------------:| ----:|
| 1      | 9             | 81   |
| 2      | 99            | 164  |
| 3      | 999           | 243  |
| 4      | 9999          | 324  |
| 13     | 9999999999999 | 1053 |

Because there is a limit of digits, the largest number has 13 digits. After the conversion, the next one would be 1053, which would definitely generate a number smaller than 324. And for the largest 3 digit number -- 999, the next one is 243. So the following generated numbers will be smaller than 243.

Using brute force, we can find such set {4,16,37,58,89,145,42,20}. If generated number appears in this set, it would be a Unhappy number.

This method is actually not recommende as it needs extra efforts to find above set.

``` Python
def isHappy(self, n: int) -> bool:

    cycle_members = {4, 16, 37, 58, 89, 145, 42, 20}

    def get_next(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    while n != 1 and n not in cycle_members:
        n = get_next(n)

    return n == 1
```    
Time complexity: O(logn)
Space complexity: O(1) 
